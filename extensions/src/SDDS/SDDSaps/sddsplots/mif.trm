/* GNUPLOT - mif.trm */
/*
 * Copyright (C) 1990   
 *
 * Permission to use,  copy,  and distribute this software and its
 * documentation for any purpose with or without fee is hereby granted,  
 * provided that the above copyright notice appear in all copies and 
 * that both that copyright notice and this permission notice appear 
 * in supporting documentation.
 *
 * Permission to modify the software is granted,  but not the right to
 * distribute the modified code.  Modifications are to be distributed 
 * as patches to released version.
 *  
 * This software  is provided "as is" without express or implied warranty.
 * 
 * This file is included by ../term.c.
 *
 * This terminal driver supports:
 *     mif
 *
 * AUTHORS
 *  Kenneth Evans, Jr. based on post.trm
 * 
 */

/* MIF driver by Kenneth Evans, Jr.,  evans@aps.anl.gov */

#include "mif_limits.h"
#include "SDDStypes.h"
#include "graph.h"

/* The following are the page size of the MIF image in inches */
#define MIF_XSIZE 5.0
#define MIF_YSIZE 4.0

#define CX(x) (double)(mif_ax*(double)(x))
#define CY(y) (double)(mif_ay*(double)(y)+mif_by)

#define MIF_XLAST (MIF_XMAX - 1)
#define MIF_YLAST (MIF_YMAX - 1)

#define MIF_VTIC (MIF_YMAX/80)
#define MIF_HTIC (MIF_YMAX/80)


#define MIF_SC (MIF_XMAX/360)		/* scale is 1pt = 10 units */
#define	MIF_LW (0.25*MIF_SC)		/* linewidth = 0.25 pts */

#define MIF_VCHAR1 (7*MIF_SC)		/* 7 point characters */
#define MIF_HCHAR1 (7*MIF_SC*6/10)

#define MIF_VCHAR2 (11*MIF_SC)		/* 11 point characters */
#define MIF_HCHAR2 (11*MIF_SC*6/10)

/* Global variables */

int mif_page=0;                  /* page count */
int mif_point_count=0; 	         /* count of lines in path */
int mif_ang=0;	       	         /* text angle */
int mif_dopolyline=0;            /* doing a polyline */
int mif_firstpolyline=1;         /* at the first point in a polyline */
int mif_newpen=1;                /* pen has changed */
int mif_linetype=0;              /* linetype */
int mif_dopage=0;                /* doing a page */
int mif_xpos=0,mif_ypos=0;       /* current position of pen */
int mif_color=0;                 /* color or BW */
int mif_defaultcolors=0;         /* use builtin colors */
double mif_defaultlinesize=0.25;     /* default linesize */
double mif_defaultdashsize=1.0;     /* default basic dash unit */
double mif_lineincrement = 0.5;   
char *mif_font;                  /* name of font in use */
enum JUSTIFY mif_justify=LEFT;   /* text justification */
double mif_ax=(double)MIF_XSIZE/(double)MIF_XMAX,mif_bx=0;
double mif_ay=-(double)MIF_YSIZE/(double)MIF_YMAX,mif_by=0;
                                 /* linear scaling parameters */
int mif_lastlinetype = -1;

unsigned long mifFlags = 0;
#define MIF_NODASH 0x0001UL

int MIF_resetlastlinetypes(void);

/**************************** MIF_init ************************************/
int MIF_init(void)
{
    char **argv;
    long argc;

    if(mif_dopage) MIF_endpage();
    mif_font="Times";/* Could be "Helvetica", "Courier", etc. */
    mif_dopolyline=mif_dopage=mif_xpos=mif_ypos=0;
    mif_firstpolyline=1;
    mif_newpen=1;
    mif_lastlinetype=-1;
    mif_color=0;

    mifFlags = 0;
    if ((argv = getDeviceArgv(&argc))) {
        if (!scanItemList(&mifFlags, argv, &argc, 0,
                        "linesizedefault", SDDS_DOUBLE, &mif_defaultlinesize, 1, 0,
                        "dashsizedefault", SDDS_DOUBLE, &mif_defaultdashsize, 1, 0,
                        "lineincrement", SDDS_DOUBLE, &mif_lineincrement, 1, 0,
                        "nodash", -1, NULL, 0, MIF_NODASH,
                        NULL))
                bomb("problem scanning device arguments for MIF device", NULL);
    }

    fprintf(outfile,"<MIFFile 4.00> # Generated by MPL/SDDSPlot\n");
    fprintf(outfile,"<Units Uin>\n");
    return 0;
}
/**************************** CMIF_init ***********************************/
int CMIF_init(void)
{
    MIF_init();
    mif_color=1;     /* Overrides color in MIF_init() */
    mif_defaultcolors=1;     /* Hardcoded for now */
    if(!mif_defaultcolors) MIF_setcolorcatalog();
    return 0;
}
/**************************** MIF_graphics ********************************/
int MIF_graphics(void)
{
    if(mif_dopage) MIF_endpage();

    MIF_resetlastlinetypes();

    mif_page++;
    mif_by=mif_page*MIF_YSIZE;
    mif_xpos=mif_ypos=0;
    mif_dopage=1;
    fprintf(outfile,"# Plot %d\n",mif_page);
    return 0;
}
/**************************** MIF_text ************************************/
int MIF_text(void)
{
    if(mif_dopage) MIF_endpage();
    return 0;
}
/**************************** MIF_reset ***********************************/
int MIF_reset(void)
{
    if(mif_dopage) MIF_endpage();
    return 0;
}
/**************************** MIF_linetype ********************************/
int MIF_linetype(int linetype)
{
    if(mif_color && mif_defaultcolors) linetype=linetype%7;
    else linetype=linetype%10;
    mif_defaultlinesize=0.25;
    if(linetype == mif_linetype) return 1;
    if(mif_dopolyline) MIF_endpolyline();
    mif_linetype=linetype;
    mif_lastlinetype=linetype;
    mif_newpen=1;
    return 0;
}
/**************************** MIF_line_thickness ********************************/
int MIF_line_thickness(int line_thickness)
{
    mif_defaultlinesize=0.25*line_thickness;
    return 0;
}
/**************************** MIF_resetlastlinetypes **********************/
int MIF_resetlastlinetypes(void)
{
    if(mif_dopolyline) MIF_endpolyline();
    mif_lastlinetype = -1;
    return 0;
}
/**************************** MIF_move ************************************/
int MIF_move(int x, int y)
{
    if(mif_dopolyline) MIF_endpolyline();
    mif_xpos=x;
    mif_ypos=y;
    return 0;
}
/**************************** MIF_vector **********************************/
int MIF_vector(int x, int y)
{

    if(!mif_dopolyline) MIF_startpolyline();
    fprintf(outfile,"  <Point %.3f\" %.3f\">\n",CX(x),CY(y));
    mif_xpos=x;
    mif_ypos=y;
    mif_point_count += 1;
    if (mif_point_count >= 10000) {     /* Not sure this is needed */
	MIF_endpolyline();
    }
    return 0;
}
/**************************** MIF_put_text ********************************/
int MIF_put_text(int x, int y, char *str)
{
/* Has not been tested! */
    if(mif_dopolyline) MIF_endpolyline();
    mif_lastlinetype = -1;
    fprintf(outfile,"<TextLine\n");
    fprintf(outfile,"  <GroupID %d>\n",mif_page);
    fprintf(outfile,"  <Font\n");
    fprintf(outfile,"    <FFamily %s>\n",mif_font);
    fprintf(outfile,"    <FSize %d>\n",(int)(MIF_VCHAR1+.5));
    fprintf(outfile,"    <FBold No>\n");
    fprintf(outfile,"    <FAngle `Regular'>\n");
    fprintf(outfile,"  > # End of font\n");
    fprintf(outfile," <TLOrigin %.3f\" %.3f\">\n",CX(mif_xpos),CY(mif_ypos));
    fprintf(outfile," <Angle %d .3>\n",mif_ang);
    switch(mif_justify) {
    case LEFT:
	fprintf(outfile," <TLAlignment Left>\n");
	break;
    case CENTRE:
	fprintf(outfile," <TLAlignment Center>\n");
	break;
    case RIGHT:
	fprintf(outfile," <TLAlignment Right>\n");
	break;
    }
    fprintf(outfile," <String `%s'>\n",str);
    fprintf(outfile,">  # End of textline\n");
    return 0;
}
/**************************** MIF_text_angle ******************************/
int MIF_text_angle(int ang)
{
    mif_ang=ang;
    return TRUE;
}
/**************************** MIF_justify_text ****************************/
int MIF_justify_text(enum JUSTIFY mode)
{
    mif_justify=mode;
    return TRUE;
}
/**************************** MIF_point ***********************************/
int MIF_point(int x, int y, int number, double size)
{
/* Not implemented */
    return 0;
}
/**************************** MIF_dot *************************************/
int MIF_dot(int x, int y, int number)
{
    if(mif_dopolyline) MIF_endpolyline();
    mif_xpos=x;
    mif_ypos=y;
    MIF_startpolyline();
    fprintf(outfile,"  <Point %.3f\" %.3f\">\n",CX(x),CY(y));
    MIF_endpolyline();
    return 0;
}
/**************************** MIF_fill_box ********************************/
int MIF_fill_box(int shade, int xl, int xh, int yl, int yh)
{
    if(mif_dopolyline) MIF_endpolyline();
    mif_newpen=1;
    mif_lastlinetype = -1;
    shade = 100-shade%101;
    fprintf(outfile,"<Rectangle\n");
    fprintf(outfile,"  <GroupID %d>\n",mif_page);
    if(mif_color) MIF_setlinetype();
    fprintf(outfile,"  <ShapeRect %.3f\" %.3f\" %.3f\" %.3f\">\n",
      CX(xl),MIF_YSIZE-CY(yh),CX(xh-xl),CY(yh-yl));
    fprintf(outfile,">  # End of rectangle\n");
    return 0;
}
/**************************** MIF_startpolyline ***************************/
int MIF_startpolyline()
{
    if(mif_dopolyline) MIF_endpolyline();
    mif_point_count=0;
    mif_dopolyline=1;
    fprintf(outfile,"<PolyLine\n");
    fprintf(outfile,"  <GroupID %d>\n",mif_page);
    if(mif_firstpolyline) {
	mif_firstpolyline=0;
	fprintf(outfile,"  <HeadCap Round>\n");
	fprintf(outfile,"  <TailCap Round>\n");
	fprintf(outfile,"  <Pen 0>\n");
	fprintf(outfile,"  <Fill 15>\n");
	if(!mif_color) fprintf(outfile,"  <ObColor `Black'>\n");
    }
    if(mif_color)
      fprintf(outfile,"  <PenWidth  %.2fpt>\n",1.0*mif_defaultlinesize);
    if(mif_newpen) MIF_setlinetype();
    fprintf(outfile,"  <Point %.3f\" %.3f\">\n",CX(mif_xpos),CY(mif_ypos));
    return 0;
}
/**************************** MIF_endpolyline *****************************/
int MIF_endpolyline(void)
{
    fprintf(outfile,">\n");
    mif_dopolyline=0;
    return 0;
}
/**************************** MIF_endpage *********************************/
int MIF_endpage(void)
{
    if(mif_dopolyline) MIF_endpolyline();
    if(mif_dopage) fprintf(outfile,"<Group <ID %d>>\n",mif_page);
    mif_dopage=0;
    mif_xpos=mif_ypos=0;
    return 0;
}
/**************************** MIF_setlinetype *****************************/
int MIF_setlinetype(void)
{
    static int lastlinetype=-1;

    mif_newpen=0;
    if(mif_linetype == lastlinetype) return 1;
    lastlinetype=mif_linetype;
/* Variable colors */
    if(mif_color && !mif_defaultcolors)
      fprintf(outfile,"  <ObColor `Line%dColor'>\n",mif_linetype);
/* Fixed colors */
    else if(mif_color) {
	switch(mif_linetype) {
	case 0:
	    fprintf(outfile,"  <ObColor `Black'>\n");
	    break;
	case 1:
	    fprintf(outfile,"  <ObColor `Red'>\n");
	    break;
	case 2:
	    fprintf(outfile,"  <ObColor `Green'>\n");
	    break;
	case 3:
	    fprintf(outfile,"  <ObColor `Blue'>\n");
	    break;
	case 4:
	    fprintf(outfile,"  <ObColor `Yellow'>\n");
	    break;
	case 5:
	    fprintf(outfile,"  <ObColor `Magenta'>\n");
	    break;
	case 6:
	    fprintf(outfile,"  <ObColor `Cyan'>\n");
	    break;
	}
    }
/* Black and White */
    else {
        if (mifFlags&MIF_NODASH) {
            fprintf(outfile, "<PenWidth  %.2fpt>\n", 1.0*mif_defaultlinesize+mif_linetype*mif_lineincrement);
            fprintf(outfile,"  <DashedPattern\n");
	    fprintf(outfile,"    <DashedStyle Solid>\n");
	    fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
            }
        else {
            switch(mif_linetype) {
              case 0:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",1.0*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Solid>\n");
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
              case 1:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",1.0*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Dashed>\n");
                fprintf(outfile,"    <NumSegments 2>\n");
                fprintf(outfile,"    <DashSegment %.1fpt>\n",4.0*mif_defaultdashsize);
                fprintf(outfile,"    <DashSegment %.1fpt>\n",1.0*mif_defaultdashsize);
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
              case 2:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",1.0*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Dashed>\n");
                fprintf(outfile,"    <NumSegments 2>\n");
                fprintf(outfile,"    <DashSegment %.1fpt>\n",2.0*mif_defaultdashsize);
                fprintf(outfile,"    <DashSegment %.1fpt>\n",3.0*mif_defaultdashsize);
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
              case 3:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",1.0*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Dashed>\n");
                fprintf(outfile,"    <NumSegments 2>\n");
                fprintf(outfile,"    <DashSegment %.1fpt>\n",1.0*mif_defaultdashsize);
                fprintf(outfile,"    <DashSegment %.1fpt>\n",1.5*mif_defaultdashsize);
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
              case 4:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",1.0*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Dashed>\n");
                fprintf(outfile,"    <NumSegments 4>\n");
                fprintf(outfile,"    <DashSegment %.1fpt>\n",5.0*mif_defaultdashsize);
                fprintf(outfile,"    <DashSegment %.1fpt>\n",2.0*mif_defaultdashsize);
                fprintf(outfile,"    <DashSegment %.1fpt>\n",1.0*mif_defaultdashsize);
                fprintf(outfile,"    <DashSegment %.1fpt>\n",2.0*mif_defaultdashsize);
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
              case 5:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",1.0*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Dashed>\n");
                fprintf(outfile,"    <NumSegments 4>\n");
                fprintf(outfile,"    <DashSegment %.1fpt>\n",4.0*mif_defaultdashsize);
                fprintf(outfile,"    <DashSegment %.1fpt>\n",3.0*mif_defaultdashsize);
                fprintf(outfile,"    <DashSegment %.1fpt>\n",1.0*mif_defaultdashsize);
                fprintf(outfile,"    <DashSegment %.1fpt>\n",3.0*mif_defaultdashsize);
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
              case 6:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",0.4*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Solid>\n");
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
              case 7:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",.15*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Solid>\n");
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
              case 8:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",4.0*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Solid>\n");
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
              case 9:
                fprintf(outfile,"  <PenWidth  %.2fpt>\n",2.25*mif_defaultlinesize);
                fprintf(outfile,"  <DashedPattern\n");
                fprintf(outfile,"    <DashedStyle Solid>\n");
                fprintf(outfile,"  > # Linetype %d\n",mif_linetype);
                break;
                }
            }
        }
    return 0;
}
/**************************** MIF_setcolorcatalog *************************/
int MIF_setcolorcatalog(void)
{
    static char *catalog=
      "<ColorCatalog\n"
      "  <Color\n"     /* Black */
      "     <ColorTag `Line0Color'>\n"
      "     <ColorCyan      0.0>\n"
      "     <ColorMagenta   0.0>\n"
      "     <ColorYellow    0.0>\n"
      "     <ColorBlack   100.0>\n"
      "   > # end of Color\n"
      "   <Color\n"     /* Red */
      "     <ColorTag `Line1Color'>\n"
      "     <ColorCyan      0.0>\n"
      "     <ColorMagenta 100.0>\n"
      "     <ColorYellow  100.0>\n"
      "     <ColorBlack     0.0>\n"
      "   > # end of Color\n"
      "   <Color\n"     /* Green */
      "     <ColorTag `Line2Color'>\n"
      "     <ColorCyan    100.0>\n"
      "     <ColorMagenta   0.0>\n"
      "     <ColorYellow  100.0>\n"
      "     <ColorBlack     0.0>\n"
      "   > # end of Color\n"
      "   <Color\n"     /* Blue */
      "     <ColorTag `Line3Color'>\n"
      "     <ColorCyan    100.0>\n"
      "     <ColorMagenta 100.0>\n"
      "     <ColorYellow    0.0>\n"
      "     <ColorBlack     0.0>\n"
      "   > # end of Color\n"
      "   <Color\n"     /* Yellow */
      "     <ColorTag `Line4Color'>\n"
      "     <ColorCyan      0.0>\n"
      "     <ColorMagenta   0.0>\n"
      "     <ColorYellow  100.0>\n"
      "     <ColorBlack     0.0>\n"
      "   > # end of Color\n"
      "   <Color\n"     /* Magenta */
      "     <ColorTag `Line5Color'>\n"
      "     <ColorCyan      0.0>\n"
      "     <ColorMagenta 100.0>\n"
      "     <ColorYellow    0.0>\n"
      "     <ColorBlack     0.0>\n"
      "   > # end of Color\n"
      "   <Color\n"     /* Cyan */
      "     <ColorTag `Line6Color'>\n"
      "     <ColorCyan    100.0>\n"
      "     <ColorMagenta   0.0>\n"
      "     <ColorYellow    0.0>\n"
      "     <ColorBlack     0.0>\n"
      "   > # end of Color\n"
      "   <Color\n"     /* Orange */
      "     <ColorTag `Line7Color'>\n"
      "     <ColorCyan      0.0>\n"
      "     <ColorMagenta  50.0>\n"
      "     <ColorYellow  100.0>\n"
      "     <ColorBlack     0.0>\n"
      "   > # end of Color\n"
      "   <Color\n"     /* Purple */
      "     <ColorTag `Line8Color'>\n"
      "     <ColorCyan     50.0>\n"
      "     <ColorMagenta 100.0>\n"
      "     <ColorYellow    0.0>\n"
      "     <ColorBlack     0.0>\n"
      "   > # end of Color\n"
      "   <Color\n"     /* Lt. Green */
      "     <ColorTag `Line9Color'>\n"
      "     <ColorCyan    100.0>\n"
      "     <ColorMagenta   0.0>\n"
      "     <ColorYellow   50.0>\n"
      "     <ColorBlack     0.0>\n"
      "   > # end of Color\n"
      "> # end of ColorCatalog\n";

	fprintf(outfile,catalog);
    return 0;
}
#undef CX
#undef CY
